'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerBase = require('../compiler-base');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _sorcery = require('sorcery');

var _sorcery2 = _interopRequireDefault(_sorcery);

var _jsStringEscape = require('js-string-escape');

var _jsStringEscape2 = _interopRequireDefault(_jsStringEscape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inputMimeTypes = ['text/typescript', 'text/tsx'];
const d = require('debug')('electron-compile:typescript-compiler');

let ts = null;
let istanbul = null;

const builtinKeys = ['hotModuleReload', 'coverage', 'babel'];

class TypeScriptCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();

    this.outMimeType = 'application/javascript';
    this.compilerOptions = {
      inlineSourceMap: true,
      inlineSources: true
    };
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  _getParsedConfigOptions(tsCompiler) {
    let parsedConfig = this.parsedConfig;

    if (!parsedConfig) {
      let opts = Object.assign({}, this.compilerOptions);
      let builtinOpts = {};
      builtinKeys.forEach(k => {
        if (k in this.compilerOptions) {
          delete opts[k];
          builtinOpts[k] = this.compilerOptions[k];
        }
      });

      const results = tsCompiler.convertCompilerOptionsFromJson(opts);

      if (results.errors && results.errors.length) {
        throw new Error(JSON.stringify(results.errors));
      }

      parsedConfig = this.parsedConfig = { typescriptOpts: results.options, builtinOpts };
    }

    return parsedConfig;
  }

  compileSync(sourceCode, filePath) {
    ts = ts || require('typescript');
    const options = this._getParsedConfigOptions(ts);

    const isTsx = filePath.match(/\.tsx$/i);
    const transpileOptions = {
      compilerOptions: options.typescriptOpts,
      fileName: filePath.match(/\.(ts|tsx)$/i) ? _path2.default.basename(filePath) : null
    };

    if (isTsx && options.builtinOpts.hotModuleReload !== false) {
      sourceCode = this.addHotModuleLoadingRegistration(sourceCode, filePath, this.getExportsForFile(sourceCode, filePath, options.typescriptOpts));
    }

    let output = ts.transpileModule(sourceCode, transpileOptions);
    let sourceMaps = output.sourceMapText ? output.sourceMapText : null;
    if (options.builtinOpts.coverage) {
      sourceMaps = null;
      istanbul = istanbul || require('istanbul');

      sourceMaps = null;
      output.outputText = new istanbul.Instrumenter().instrumentSync(output.outputText, filePath);
    }

    d(JSON.stringify(output.diagnostics));

    const babelOpts = this.parsedConfig.builtinOpts.babel;
    if (babelOpts) {
      if (!this.babel) {
        const BabelCompiler = require("./babel").default;
        this.babel = new BabelCompiler();
        this.babel.compilerOptions = babelOpts;
      }
      if (!this.sorcery) {
        this.sorcer = require("sorcery");
      }
      let tsOutputPath = filePath.replace(/.tsx?$/i, ".js");
      let babelOutputPath = filePath.replace(/.tsx?$/i, ".babel.js");

      output.outputText = output.outputText.replace(/\/\/# sourceMap.*/g, "");

      let babelOutput = this.babel.compileSync(output.outputText, tsOutputPath);
      let chain = _sorcery2.default.loadSync(babelOutputPath, {
        content: {
          [filePath]: sourceCode,
          [tsOutputPath]: output.outputText,
          [babelOutputPath]: babelOutput.code
        },
        sourcemaps: {
          [tsOutputPath]: JSON.parse(sourceMaps),
          [babelOutputPath]: JSON.parse(babelOutput.sourceMaps)
        }
      });
      let finalSourceMaps = chain.apply();
      let outputCode = babelOutput.code + "\n//# sourceMappingURL=" + finalSourceMaps.toUrl();

      // the only way to make sourceMaps usable seems to be to have
      // them inlined right now, see https://github.com/electron/electron-compile/issues/172#issuecomment-277146112
      return {
        code: outputCode,
        mimeType: babelOutput.mimeType
      };
    }

    return {
      code: output.outputText,
      mimeType: this.outMimeType,
      sourceMaps
    };
  }

  addHotModuleLoadingRegistration(sourceCode, fileName, exports) {
    if (exports.length < 1) return sourceCode;

    let registrations = exports.map(x => {
      let id = `${x}` == 'default' ? '(typeof _default !== \'undefined\' ? _default : exports.default)' : `${x}`;
      let name = `"${x}"`;
      return `__REACT_HOT_LOADER__.register(${id}, ${name}, __FILENAME__);\n`;
    });

    let tmpl = `
${sourceCode}

if (typeof __REACT_HOT_LOADER__ !== 'undefined') {
  const __FILENAME__ = "${(0, _jsStringEscape2.default)(fileName)}";
  ${registrations}
}`;

    return tmpl;
  }

  getExportsForFile(sourceCode, fileName, tsOptions) {
    let sourceFile = ts.createSourceFile(fileName, sourceCode, ts.ScriptTarget.ES6);
    let ret = [];

    // Walk the tree to search for classes
    let visit = node => {
      if (!this.isNodeExported(node)) return;

      if (node.kind === ts.SyntaxKind.ClassDeclaration || node.kind === ts.SyntaxKind.FunctionDeclaration) {
        ret.push(node.name.text);
      }
    };

    ts.forEachChild(sourceFile, visit);

    return ret;
  }

  isNodeExported(node) {
    return (node.flags & ts.NodeFlags.Export) !== 0 || node.parent && node.parent.kind === ts.SyntaxKind.SourceFile;
  }

  getCompilerVersion() {
    return require('typescript/package.json').version;
  }
}
exports.default = TypeScriptCompiler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy90eXBlc2NyaXB0LmpzIl0sIm5hbWVzIjpbImlucHV0TWltZVR5cGVzIiwiZCIsInJlcXVpcmUiLCJ0cyIsImlzdGFuYnVsIiwiYnVpbHRpbktleXMiLCJUeXBlU2NyaXB0Q29tcGlsZXIiLCJTaW1wbGVDb21waWxlckJhc2UiLCJjb25zdHJ1Y3RvciIsIm91dE1pbWVUeXBlIiwiY29tcGlsZXJPcHRpb25zIiwiaW5saW5lU291cmNlTWFwIiwiaW5saW5lU291cmNlcyIsImdldElucHV0TWltZVR5cGVzIiwiX2dldFBhcnNlZENvbmZpZ09wdGlvbnMiLCJ0c0NvbXBpbGVyIiwicGFyc2VkQ29uZmlnIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsImJ1aWx0aW5PcHRzIiwiZm9yRWFjaCIsImsiLCJyZXN1bHRzIiwiY29udmVydENvbXBpbGVyT3B0aW9uc0Zyb21Kc29uIiwiZXJyb3JzIiwibGVuZ3RoIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwidHlwZXNjcmlwdE9wdHMiLCJvcHRpb25zIiwiY29tcGlsZVN5bmMiLCJzb3VyY2VDb2RlIiwiZmlsZVBhdGgiLCJpc1RzeCIsIm1hdGNoIiwidHJhbnNwaWxlT3B0aW9ucyIsImZpbGVOYW1lIiwicGF0aCIsImJhc2VuYW1lIiwiaG90TW9kdWxlUmVsb2FkIiwiYWRkSG90TW9kdWxlTG9hZGluZ1JlZ2lzdHJhdGlvbiIsImdldEV4cG9ydHNGb3JGaWxlIiwib3V0cHV0IiwidHJhbnNwaWxlTW9kdWxlIiwic291cmNlTWFwcyIsInNvdXJjZU1hcFRleHQiLCJjb3ZlcmFnZSIsIm91dHB1dFRleHQiLCJJbnN0cnVtZW50ZXIiLCJpbnN0cnVtZW50U3luYyIsImRpYWdub3N0aWNzIiwiYmFiZWxPcHRzIiwiYmFiZWwiLCJCYWJlbENvbXBpbGVyIiwiZGVmYXVsdCIsInNvcmNlcnkiLCJzb3JjZXIiLCJ0c091dHB1dFBhdGgiLCJyZXBsYWNlIiwiYmFiZWxPdXRwdXRQYXRoIiwiYmFiZWxPdXRwdXQiLCJjaGFpbiIsImxvYWRTeW5jIiwiY29udGVudCIsImNvZGUiLCJzb3VyY2VtYXBzIiwicGFyc2UiLCJmaW5hbFNvdXJjZU1hcHMiLCJhcHBseSIsIm91dHB1dENvZGUiLCJ0b1VybCIsIm1pbWVUeXBlIiwiZXhwb3J0cyIsInJlZ2lzdHJhdGlvbnMiLCJtYXAiLCJ4IiwiaWQiLCJuYW1lIiwidG1wbCIsInRzT3B0aW9ucyIsInNvdXJjZUZpbGUiLCJjcmVhdGVTb3VyY2VGaWxlIiwiU2NyaXB0VGFyZ2V0IiwiRVM2IiwicmV0IiwidmlzaXQiLCJub2RlIiwiaXNOb2RlRXhwb3J0ZWQiLCJraW5kIiwiU3ludGF4S2luZCIsIkNsYXNzRGVjbGFyYXRpb24iLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwicHVzaCIsInRleHQiLCJmb3JFYWNoQ2hpbGQiLCJmbGFncyIsIk5vZGVGbGFncyIsIkV4cG9ydCIsInBhcmVudCIsIlNvdXJjZUZpbGUiLCJnZXRDb21waWxlclZlcnNpb24iLCJ2ZXJzaW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLE1BQU1BLGlCQUFpQixDQUFDLGlCQUFELEVBQW9CLFVBQXBCLENBQXZCO0FBQ0EsTUFBTUMsSUFBSUMsUUFBUSxPQUFSLEVBQWlCLHNDQUFqQixDQUFWOztBQUVBLElBQUlDLEtBQUssSUFBVDtBQUNBLElBQUlDLFdBQVcsSUFBZjs7QUFFQSxNQUFNQyxjQUFjLENBQUMsaUJBQUQsRUFBb0IsVUFBcEIsRUFBZ0MsT0FBaEMsQ0FBcEI7O0FBRWUsTUFBTUMsa0JBQU4sU0FBaUNDLGdDQUFqQyxDQUFvRDtBQUNqRUMsZ0JBQWM7QUFDWjs7QUFFQSxTQUFLQyxXQUFMLEdBQW1CLHdCQUFuQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUI7QUFDckJDLHVCQUFpQixJQURJO0FBRXJCQyxxQkFBZTtBQUZNLEtBQXZCO0FBSUQ7O0FBRUQsU0FBT0MsaUJBQVAsR0FBMkI7QUFDekIsV0FBT2IsY0FBUDtBQUNE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LEVBQXFCO0FBQ25CLFdBQU8sQ0FBQ0EsS0FBS1MsS0FBTCxHQUFhOUYsR0FBRytGLFNBQUgsQ0FBYUMsTUFBM0IsTUFBdUMsQ0FBdkMsSUFBNkNYLEtBQUtZLE1BQUwsSUFBZVosS0FBS1ksTUFBTCxDQUFZVixJQUFaLEtBQXFCdkYsR0FBR3dGLFVBQUgsQ0FBY1UsVUFBdEc7QUFDRDs7QUFFREMsdUJBQXFCO0FBQ25CLFdBQU9wRyxRQUFRLHlCQUFSLEVBQW1DcUcsT0FBMUM7QUFDRDtBQTNKZ0U7a0JBQTlDakcsa0IiLCJmaWxlIjoidHlwZXNjcmlwdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2ltcGxlQ29tcGlsZXJCYXNlfSBmcm9tICcuLi9jb21waWxlci1iYXNlJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHNvcmNlcnkgZnJvbSAnc29yY2VyeSc7XG5pbXBvcnQganNFc2NhcGUgZnJvbSAnanMtc3RyaW5nLWVzY2FwZSc7XG5cbmNvbnN0IGlucHV0TWltZVR5cGVzID0gWyd0ZXh0L3R5cGVzY3JpcHQnLCAndGV4dC90c3gnXTtcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOnR5cGVzY3JpcHQtY29tcGlsZXInKTtcblxubGV0IHRzID0gbnVsbDtcbmxldCBpc3RhbmJ1bCA9IG51bGw7XG5cbmNvbnN0IGJ1aWx0aW5LZXlzID0gWydob3RNb2R1bGVSZWxvYWQnLCAnY292ZXJhZ2UnLCAnYmFiZWwnXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZVNjcmlwdENvbXBpbGVyIGV4dGVuZHMgU2ltcGxlQ29tcGlsZXJCYXNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3V0TWltZVR5cGUgPSAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc7XG4gICAgdGhpcy5jb21waWxlck9wdGlvbnMgPSB7XG4gICAgICBpbmxpbmVTb3VyY2VNYXA6IHRydWUsXG4gICAgICBpbmxpbmVTb3VyY2VzOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnB1dE1pbWVUeXBlcygpIHtcbiAgICByZXR1cm4gaW5wdXRNaW1lVHlwZXM7XG4gIH1cblxuICBfZ2V0UGFyc2VkQ29uZmlnT3B0aW9ucyh0c0NvbXBpbGVyKSB7XG4gICAgbGV0IHBhcnNlZENvbmZpZyA9IHRoaXMucGFyc2VkQ29uZmlnO1xuXG4gICAgaWYgKCFwYXJzZWRDb25maWcpIHtcbiAgICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21waWxlck9wdGlvbnMpO1xuICAgICAgbGV0IGJ1aWx0aW5PcHRzID0ge307XG4gICAgICBidWlsdGluS2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgIGlmIChrIGluIHRoaXMuY29tcGlsZXJPcHRpb25zKSB7XG4gICAgICAgICAgZGVsZXRlIG9wdHNba107XG4gICAgICAgICAgYnVpbHRpbk9wdHNba10gPSB0aGlzLmNvbXBpbGVyT3B0aW9uc1trXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB0c0NvbXBpbGVyLmNvbnZlcnRDb21waWxlck9wdGlvbnNGcm9tSnNvbihvcHRzKTtcblxuICAgICAgaWYgKHJlc3VsdHMuZXJyb3JzICYmIHJlc3VsdHMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzdWx0cy5lcnJvcnMpKTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VkQ29uZmlnID0gdGhpcy5wYXJzZWRDb25maWcgPSB7IHR5cGVzY3JpcHRPcHRzOiByZXN1bHRzLm9wdGlvbnMsIGJ1aWx0aW5PcHRzIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZENvbmZpZztcbiAgfVxuXG4gIGNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoKSB7XG4gICAgdHMgPSB0cyB8fCByZXF1aXJlKCd0eXBlc2NyaXB0Jyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldFBhcnNlZENvbmZpZ09wdGlvbnModHMpO1xuXG4gICAgY29uc3QgaXNUc3ggPSBmaWxlUGF0aC5tYXRjaCgvXFwudHN4JC9pKTtcbiAgICBjb25zdCB0cmFuc3BpbGVPcHRpb25zID0ge1xuICAgICAgY29tcGlsZXJPcHRpb25zOiBvcHRpb25zLnR5cGVzY3JpcHRPcHRzLFxuICAgICAgZmlsZU5hbWU6IGZpbGVQYXRoLm1hdGNoKC9cXC4odHN8dHN4KSQvaSkgPyBwYXRoLmJhc2VuYW1lKGZpbGVQYXRoKSA6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGlzVHN4ICYmIG9wdGlvbnMuYnVpbHRpbk9wdHMuaG90TW9kdWxlUmVsb2FkICE9PSBmYWxzZSkge1xuICAgICAgc291cmNlQ29kZSA9IHRoaXMuYWRkSG90TW9kdWxlTG9hZGluZ1JlZ2lzdHJhdGlvbihzb3VyY2VDb2RlLCBmaWxlUGF0aCwgdGhpcy5nZXRFeHBvcnRzRm9yRmlsZShzb3VyY2VDb2RlLCBmaWxlUGF0aCwgb3B0aW9ucy50eXBlc2NyaXB0T3B0cykpO1xuICAgIH1cblxuICAgIGxldCBvdXRwdXQgPSB0cy50cmFuc3BpbGVNb2R1bGUoc291cmNlQ29kZSwgdHJhbnNwaWxlT3B0aW9ucyk7XG4gICAgbGV0IHNvdXJjZU1hcHMgPSBvdXRwdXQuc291cmNlTWFwVGV4dCA/IG91dHB1dC5zb3VyY2VNYXBUZXh0IDogbnVsbDtcbiAgICBpZiAob3B0aW9ucy5idWlsdGluT3B0cy5jb3ZlcmFnZSkge1xuICAgICAgc291cmNlTWFwcyA9IG51bGw7XG4gICAgICBpc3RhbmJ1bCA9IGlzdGFuYnVsIHx8IHJlcXVpcmUoJ2lzdGFuYnVsJyk7XG5cbiAgICAgIHNvdXJjZU1hcHMgPSBudWxsO1xuICAgICAgb3V0cHV0Lm91dHB1dFRleHQgPSAobmV3IGlzdGFuYnVsLkluc3RydW1lbnRlcigpKS5pbnN0cnVtZW50U3luYyhvdXRwdXQub3V0cHV0VGV4dCwgZmlsZVBhdGgpO1xuICAgIH1cblxuICAgIGQoSlNPTi5zdHJpbmdpZnkob3V0cHV0LmRpYWdub3N0aWNzKSk7XG5cbiAgICBjb25zdCBiYWJlbE9wdHMgPSB0aGlzLnBhcnNlZENvbmZpZy5idWlsdGluT3B0cy5iYWJlbDtcbiAgICBpZiAoYmFiZWxPcHRzKSB7XG4gICAgICBpZiAoIXRoaXMuYmFiZWwpIHtcbiAgICAgICAgY29uc3QgQmFiZWxDb21waWxlciA9IHJlcXVpcmUoXCIuL2JhYmVsXCIpLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuYmFiZWwgPSBuZXcgQmFiZWxDb21waWxlcigpO1xuICAgICAgICB0aGlzLmJhYmVsLmNvbXBpbGVyT3B0aW9ucyA9IGJhYmVsT3B0cztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zb3JjZXJ5KSB7XG4gICAgICAgIHRoaXMuc29yY2VyID0gcmVxdWlyZShcInNvcmNlcnlcIik7XG4gICAgICB9XG4gICAgICBsZXQgdHNPdXRwdXRQYXRoID0gZmlsZVBhdGgucmVwbGFjZSgvLnRzeD8kL2ksIFwiLmpzXCIpO1xuICAgICAgbGV0IGJhYmVsT3V0cHV0UGF0aCA9IGZpbGVQYXRoLnJlcGxhY2UoLy50c3g/JC9pLCBcIi5iYWJlbC5qc1wiKTtcblxuICAgICAgb3V0cHV0Lm91dHB1dFRleHQgPSBvdXRwdXQub3V0cHV0VGV4dC5yZXBsYWNlKC9cXC9cXC8jIHNvdXJjZU1hcC4qL2csIFwiXCIpO1xuXG4gICAgICBsZXQgYmFiZWxPdXRwdXQgPSB0aGlzLmJhYmVsLmNvbXBpbGVTeW5jKG91dHB1dC5vdXRwdXRUZXh0LCB0c091dHB1dFBhdGgpO1xuICAgICAgbGV0IGNoYWluID0gc29yY2VyeS5sb2FkU3luYyhiYWJlbE91dHB1dFBhdGgsIHtcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgIFtmaWxlUGF0aF06IHNvdXJjZUNvZGUsXG4gICAgICAgICAgW3RzT3V0cHV0UGF0aF06IG91dHB1dC5vdXRwdXRUZXh0LFxuICAgICAgICAgIFtiYWJlbE91dHB1dFBhdGhdOiBiYWJlbE91dHB1dC5jb2RlLFxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VtYXBzOiB7XG4gICAgICAgICAgW3RzT3V0cHV0UGF0aF06IEpTT04ucGFyc2Uoc291cmNlTWFwcyksXG4gICAgICAgICAgW2JhYmVsT3V0cHV0UGF0aF06IEpTT04ucGFyc2UoYmFiZWxPdXRwdXQuc291cmNlTWFwcyksXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGV0IGZpbmFsU291cmNlTWFwcyA9IGNoYWluLmFwcGx5KCk7XG4gICAgICBsZXQgb3V0cHV0Q29kZSA9IGJhYmVsT3V0cHV0LmNvZGUgKyBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgZmluYWxTb3VyY2VNYXBzLnRvVXJsKCk7XG5cbiAgICAgIC8vIHRoZSBvbmx5IHdheSB0byBtYWtlIHNvdXJjZU1hcHMgdXNhYmxlIHNlZW1zIHRvIGJlIHRvIGhhdmVcbiAgICAgIC8vIHRoZW0gaW5saW5lZCByaWdodCBub3csIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24tY29tcGlsZS9pc3N1ZXMvMTcyI2lzc3VlY29tbWVudC0yNzcxNDYxMTJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IG91dHB1dENvZGUsXG4gICAgICAgIG1pbWVUeXBlOiBiYWJlbE91dHB1dC5taW1lVHlwZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IG91dHB1dC5vdXRwdXRUZXh0LFxuICAgICAgbWltZVR5cGU6IHRoaXMub3V0TWltZVR5cGUsXG4gICAgICBzb3VyY2VNYXBzXG4gICAgfTtcbiAgfVxuXG4gIGFkZEhvdE1vZHVsZUxvYWRpbmdSZWdpc3RyYXRpb24oc291cmNlQ29kZSwgZmlsZU5hbWUsIGV4cG9ydHMpIHtcbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPCAxKSByZXR1cm4gc291cmNlQ29kZTtcblxuICAgIGxldCByZWdpc3RyYXRpb25zID0gZXhwb3J0cy5tYXAoeCA9PiB7XG4gICAgICBsZXQgaWQgPSBgJHt4fWAgPT0gJ2RlZmF1bHQnID8gJyh0eXBlb2YgX2RlZmF1bHQgIT09IFxcJ3VuZGVmaW5lZFxcJyA/IF9kZWZhdWx0IDogZXhwb3J0cy5kZWZhdWx0KScgOiBgJHt4fWBcbiAgICAgIGxldCBuYW1lID0gYFwiJHt4fVwiYFxuICAgICAgcmV0dXJuIGBfX1JFQUNUX0hPVF9MT0FERVJfXy5yZWdpc3Rlcigke2lkfSwgJHtuYW1lfSwgX19GSUxFTkFNRV9fKTtcXG5gXG4gICAgfSk7XG5cbiAgICBsZXQgdG1wbCA9IGBcbiR7c291cmNlQ29kZX1cblxuaWYgKHR5cGVvZiBfX1JFQUNUX0hPVF9MT0FERVJfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uc3QgX19GSUxFTkFNRV9fID0gXCIke2pzRXNjYXBlKGZpbGVOYW1lKX1cIjtcbiAgJHtyZWdpc3RyYXRpb25zfVxufWA7XG5cbiAgICByZXR1cm4gdG1wbDtcbiAgfVxuXG4gIGdldEV4cG9ydHNGb3JGaWxlKHNvdXJjZUNvZGUsIGZpbGVOYW1lLCB0c09wdGlvbnMpIHtcbiAgICBsZXQgc291cmNlRmlsZSA9IHRzLmNyZWF0ZVNvdXJjZUZpbGUoZmlsZU5hbWUsIHNvdXJjZUNvZGUsIHRzLlNjcmlwdFRhcmdldC5FUzYpO1xuICAgIGxldCByZXQgPSBbXTtcblxuICAgIC8vIFdhbGsgdGhlIHRyZWUgdG8gc2VhcmNoIGZvciBjbGFzc2VzXG4gICAgbGV0IHZpc2l0ID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc05vZGVFeHBvcnRlZChub2RlKSkgcmV0dXJuO1xuICAgICAgXG4gICAgICBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb24gfHwgbm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgICAgcmV0LnB1c2gobm9kZS5uYW1lLnRleHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0cy5mb3JFYWNoQ2hpbGQoc291cmNlRmlsZSwgdmlzaXQpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlzTm9kZUV4cG9ydGVkKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuRXhwb3J0KSAhPT0gMCB8fCAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Tb3VyY2VGaWxlKTtcbiAgfVxuXG4gIGdldENvbXBpbGVyVmVyc2lvbigpIHtcbiAgICByZXR1cm4gcmVxdWlyZSgndHlwZXNjcmlwdC9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICB9XG59XG4iXX0=