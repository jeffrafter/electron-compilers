'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _compilerBase = require('../compiler-base');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const mimeTypes = ['text/jsx', 'application/javascript'];
let babel = null;
let istanbul = null;

class BabelCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();
  }

  static getInputMimeTypes() {
    return mimeTypes;
  }

  // NB: This method exists to stop Babel from trying to load plugins from the
  // app's node_modules directory, which in a production app doesn't have Babel
  // installed in it. Instead, we try to load from our entry point's node_modules
  // directory (i.e. Grunt perhaps), and if it doesn't work, just keep going.
  attemptToPreload(names, prefix) {
    const fixupModule = exp => {
      // NB: Some plugins like transform-decorators-legacy, use import/export
      // semantics, and others don't
      if ('default' in exp) return exp['default'];
      return exp;
    };

    const preloadStrategies = [() => names.map(x => fixupModule(require.main.require(`babel-${prefix}-${x}`))), () => {
      let nodeModulesAboveUs = _path2.default.resolve(__dirname, '..', '..', '..');
      return names.map(x => fixupModule(require(_path2.default.join(nodeModulesAboveUs, `babel-${prefix}-${x}`))));
    }, () => names.map(x => fixupModule(require(`babel-${prefix}-${x}`)))];

    for (let strategy of preloadStrategies) {
      try {
        return strategy();
      } catch (e) {
        continue;
      }
    }

    return null;
  }

  compileSync(sourceCode, filePath, compilerContext) {
    babel = babel || require('babel-core');

    let opts = Object.assign({}, this.compilerOptions, {
      filename: filePath,
      ast: false,
      babelrc: false
    });

    let useCoverage = false;
    if ('coverage' in opts) {
      useCoverage = !!opts.coverage;
      delete opts.coverage;
    }

    if ('plugins' in opts) {
      let plugins = this.attemptToPreload(opts.plugins, 'plugin');
      if (plugins && plugins.length === opts.plugins.length) opts.plugins = plugins;
    }

    if ('presets' in opts) {
      let presets = this.attemptToPreload(opts.presets, 'preset');
      if (presets && presets.length === opts.presets.length) opts.presets = presets;
    }

    const output = babel.transform(sourceCode, opts);
    let sourceMaps = output.map ? JSON.stringify(output.map) : null;

    let code = output.code;
    if (useCoverage) {
      istanbul = istanbul || require('istanbul');

      sourceMaps = null;
      code = new istanbul.Instrumenter().instrumentSync(output.code, filePath);
    }

    return { code, sourceMaps, mimeType: 'application/javascript' };
  }

  getCompilerVersion() {
    return require('babel-core/package.json').version;
  }
}
exports.default = BabelCompiler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy9iYWJlbC5qcyJdLCJuYW1lcyI6WyJtaW1lVHlwZXMiLCJiYWJlbCIsImlzdGFuYnVsIiwiQmFiZWxDb21waWxlciIsIlNpbXBsZUNvbXBpbGVyQmFzZSIsImNvbnN0cnVjdG9yIiwiZ2V0SW5wdXRNaW1lVHlwZXMiLCJhdHRlbXB0VG9QcmVsb2FkIiwibmFtZXMiLCJwcmVmaXgiLCJmaXh1cE1vZHVsZSIsImV4cCIsInByZWxvYWRTdHJhdGVnaWVzIiwibWFwIiwieCIsInJlcXVpcmUiLCJtYWluIiwibm9kZU1vZHVsZXNBYm92ZVVzIiwicGF0aCIsInJlc29sdmUiLCJfX2Rpcm5hbWUiLCJqb2luIiwic3RyYXRlZ3kiLCJlIiwiY29tcGlsZVN5bmMiLCJzb3VyY2VDb2RlIiwiZmlsZVBhdGgiLCJjb21waWxlckNvbnRleHQiLCJvcHRzIiwiT2JqZWN0IiwiYXNzaWduIiwiY29tcGlsZXJPcHRpb25zIiwiZmlsZW5hbWUiLCJhc3QiLCJiYWJlbHJjIiwidXNlQ292ZXJhZ2UiLCJjb3ZlcmFnZSIsInBsdWdpbnMiLCJsZW5ndGgiLCJwcmVzZXRzIiwib3V0cHV0IiwidHJhbnNmb3JtIiwic291cmNlTWFwcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb2RlIiwiSW5zdHJ1bWVudGVyIiwiaW5zdHJ1bWVudFN5bmMiLCJtaW1lVHlwZSIsImdldENvbXBpbGVyVmVyc2lvbiIsInZlcnNpb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFFQSxNQUFNQSxZQUFZLENBQUMsVUFBRCxFQUFhLHdCQUFiLENBQWxCO0FBQ0EsSUFBSUMsUUFBUSxJQUFaO0FBQ0EsSUFBSUMsV0FBVyxJQUFmOztBQUVlLE1BQU1DLGFBQU4sU0FBNEJDLGdDQUE1QixDQUErQztBQUM1REMsZ0JBQWM7QUFDWjtBQUNEOztBQUVELFNBQU9DLGlCQUFQLEdBQTJCO0FBQ3pCLFdBQU9OLFNBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNB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MUQsQ0FBUDtBQUNEOztBQUVELFdBQU8sRUFBRW1CLElBQUYsRUFBUUgsVUFBUixFQUFvQk0sVUFBVSx3QkFBOUIsRUFBUDtBQUNEOztBQUVEQyx1QkFBcUI7QUFDbkIsV0FBT2xDLFFBQVEseUJBQVIsRUFBbUNtQyxPQUExQztBQUNEO0FBbEYyRDtrQkFBekMvQyxhIiwiZmlsZSI6ImJhYmVsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQge1NpbXBsZUNvbXBpbGVyQmFzZX0gZnJvbSAnLi4vY29tcGlsZXItYmFzZSc7XG5cbmNvbnN0IG1pbWVUeXBlcyA9IFsndGV4dC9qc3gnLCAnYXBwbGljYXRpb24vamF2YXNjcmlwdCddO1xubGV0IGJhYmVsID0gbnVsbDtcbmxldCBpc3RhbmJ1bCA9IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhYmVsQ29tcGlsZXIgZXh0ZW5kcyBTaW1wbGVDb21waWxlckJhc2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgc3RhdGljIGdldElucHV0TWltZVR5cGVzKCkge1xuICAgIHJldHVybiBtaW1lVHlwZXM7XG4gIH1cblxuICAvLyBOQjogVGhpcyBtZXRob2QgZXhpc3RzIHRvIHN0b3AgQmFiZWwgZnJvbSB0cnlpbmcgdG8gbG9hZCBwbHVnaW5zIGZyb20gdGhlXG4gIC8vIGFwcCdzIG5vZGVfbW9kdWxlcyBkaXJlY3RvcnksIHdoaWNoIGluIGEgcHJvZHVjdGlvbiBhcHAgZG9lc24ndCBoYXZlIEJhYmVsXG4gIC8vIGluc3RhbGxlZCBpbiBpdC4gSW5zdGVhZCwgd2UgdHJ5IHRvIGxvYWQgZnJvbSBvdXIgZW50cnkgcG9pbnQncyBub2RlX21vZHVsZXNcbiAgLy8gZGlyZWN0b3J5IChpLmUuIEdydW50IHBlcmhhcHMpLCBhbmQgaWYgaXQgZG9lc24ndCB3b3JrLCBqdXN0IGtlZXAgZ29pbmcuXG4gIGF0dGVtcHRUb1ByZWxvYWQobmFtZXMsIHByZWZpeCkge1xuICAgIGNvbnN0IGZpeHVwTW9kdWxlID0gKGV4cCkgPT4ge1xuICAgICAgLy8gTkI6IFNvbWUgcGx1Z2lucyBsaWtlIHRyYW5zZm9ybS1kZWNvcmF0b3JzLWxlZ2FjeSwgdXNlIGltcG9ydC9leHBvcnRcbiAgICAgIC8vIHNlbWFudGljcywgYW5kIG90aGVycyBkb24ndFxuICAgICAgaWYgKCdkZWZhdWx0JyBpbiBleHApIHJldHVybiBleHBbJ2RlZmF1bHQnXTtcbiAgICAgIHJldHVybiBleHA7XG4gICAgfTtcblxuICAgIGNvbnN0IHByZWxvYWRTdHJhdGVnaWVzID0gW1xuICAgICAgKCkgPT4gbmFtZXMubWFwKCh4KSA9PiBmaXh1cE1vZHVsZShyZXF1aXJlLm1haW4ucmVxdWlyZShgYmFiZWwtJHtwcmVmaXh9LSR7eH1gKSkpLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBsZXQgbm9kZU1vZHVsZXNBYm92ZVVzID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJy4uJyk7XG4gICAgICAgIHJldHVybiBuYW1lcy5tYXAoKHgpID0+IGZpeHVwTW9kdWxlKHJlcXVpcmUocGF0aC5qb2luKG5vZGVNb2R1bGVzQWJvdmVVcywgYGJhYmVsLSR7cHJlZml4fS0ke3h9YCkpKSk7XG4gICAgICB9LFxuICAgICAgKCkgPT4gbmFtZXMubWFwKCh4KSA9PiBmaXh1cE1vZHVsZShyZXF1aXJlKGBiYWJlbC0ke3ByZWZpeH0tJHt4fWApKSlcbiAgICBdO1xuXG4gICAgZm9yIChsZXQgc3RyYXRlZ3kgb2YgcHJlbG9hZFN0cmF0ZWdpZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzdHJhdGVneSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoLCBjb21waWxlckNvbnRleHQpIHtcbiAgICBiYWJlbCA9IGJhYmVsIHx8IHJlcXVpcmUoJ2JhYmVsLWNvcmUnKTtcblxuICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21waWxlck9wdGlvbnMsIHtcbiAgICAgIGZpbGVuYW1lOiBmaWxlUGF0aCxcbiAgICAgIGFzdDogZmFsc2UsXG4gICAgICBiYWJlbHJjOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgbGV0IHVzZUNvdmVyYWdlID0gZmFsc2U7XG4gICAgaWYgKCdjb3ZlcmFnZScgaW4gb3B0cykge1xuICAgICAgdXNlQ292ZXJhZ2UgPSAhIW9wdHMuY292ZXJhZ2U7XG4gICAgICBkZWxldGUgb3B0cy5jb3ZlcmFnZTtcbiAgICB9XG5cbiAgICBpZiAoJ3BsdWdpbnMnIGluIG9wdHMpIHtcbiAgICAgIGxldCBwbHVnaW5zID0gdGhpcy5hdHRlbXB0VG9QcmVsb2FkKG9wdHMucGx1Z2lucywgJ3BsdWdpbicpO1xuICAgICAgaWYgKHBsdWdpbnMgJiYgcGx1Z2lucy5sZW5ndGggPT09IG9wdHMucGx1Z2lucy5sZW5ndGgpIG9wdHMucGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgfVxuXG4gICAgaWYgKCdwcmVzZXRzJyBpbiBvcHRzKSB7XG4gICAgICBsZXQgcHJlc2V0cyA9IHRoaXMuYXR0ZW1wdFRvUHJlbG9hZChvcHRzLnByZXNldHMsICdwcmVzZXQnKTtcbiAgICAgIGlmIChwcmVzZXRzICYmIHByZXNldHMubGVuZ3RoID09PSBvcHRzLnByZXNldHMubGVuZ3RoKSBvcHRzLnByZXNldHMgPSBwcmVzZXRzO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dCA9IGJhYmVsLnRyYW5zZm9ybShzb3VyY2VDb2RlLCBvcHRzKTtcbiAgICBsZXQgc291cmNlTWFwcyA9IG91dHB1dC5tYXAgPyBKU09OLnN0cmluZ2lmeShvdXRwdXQubWFwKSA6IG51bGw7XG5cbiAgICBsZXQgY29kZSA9IG91dHB1dC5jb2RlO1xuICAgIGlmICh1c2VDb3ZlcmFnZSkge1xuICAgICAgaXN0YW5idWwgPSBpc3RhbmJ1bCB8fCByZXF1aXJlKCdpc3RhbmJ1bCcpO1xuXG4gICAgICBzb3VyY2VNYXBzID0gbnVsbDtcbiAgICAgIGNvZGUgPSAobmV3IGlzdGFuYnVsLkluc3RydW1lbnRlcigpKS5pbnN0cnVtZW50U3luYyhvdXRwdXQuY29kZSwgZmlsZVBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNvZGUsIHNvdXJjZU1hcHMsIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsIH07XG4gIH1cblxuICBnZXRDb21waWxlclZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ2JhYmVsLWNvcmUvcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiAgfVxufVxuIl19